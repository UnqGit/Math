Rect(const std::initializer_list<Type> &il, const size_t rows, const size_t columns): m_rows(rows), m_columns(columns) {
    if (rows * columns == 0) {
        m_rows = 0;
        m_columns = 0;
    }
    if (rows * columns != il.size()) m_data = new Type[il.size()]();
    else m_data = new Type[il.size()];
    size_t min = std::min(rows * columns, il.size());
    std::copy(il.begin(), il.begin() + min, m_data);
}


Rect(const std::initializer_list<Type> &il, const size_t rows, const size_t columns) requires std::default_initializable<Type> : m_rows(rows), m_columns(columns) {
    if (rows * columns == 0) {
        m_rows = 0;
        m_columns = 0;
    }
    if (rows * columns != il.size()) m_data = new Type[il.size()]();
    else m_data = new Type[il.size()];
    size_t min = std::min(rows * columns, il.size());
    std::copy(il.begin(), il.begin() + min, m_data);
}


Rect(const std::initializer_list<Type> &il, const size_t rows, const size_t columns) requires (!std::default_initializable<Type>): m_rows(rows), m_columns(columns) {
    if (rows * columns == 0) {
        m_rows = 0;
        m_columns = 0;
    }
    if (rows * columns != il.size()) throw std::invalid_argument("initializer list size and size of matrix should be equal(only for non-defualt_initializable objects.)");
    m_data = new Type[il.size()];
    std::copy(il.begin(), il.end(), m_data);
}